---
title: "Time series analysis in the frequency domain"
subtitle: "FISH 507 â€“ Applied Time Series Analysis"
author: "Mark Scheuerell"
date: "28 Feb 2019"
output:
  ioslides_presentation:
    css: lecture_slides.css
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(MARSS)
set.seed(123)
```

## Topics for today

What is the frequency domain?

Fourier transforms

Spectral analysis

Wavelets


## Time domain

```{r}
par(mai = c(0.9,0.9,0.3,0.1), omi = c(0,0,0,0))

plot.ts(cumsum(rnorm(50,0,1)),
        ylab = expression(italic(x[t])))
```

We having been examining changes in $x_t$ over time


## Time domain

We can think of this as comparing changes in amplitude (displacement) with time


## Frequency domain

Today we'll consider how amplitude changes with frequency


## Jean-Baptiste Fourier (1768 - 1830)

French mathematician & physicist best known for his studies of heat transfer

First described what we now call the "greenhouse effect"


## Solving hard problems

Solving the heat equation involves solving _partial differential equations_ conditional on some boundary conditions

$$
\begin{matrix}
\large \text{Problem} \\
really \Bigg \downarrow hard \\
\large \text{Solution}
\end{matrix}
$$


## Fourier's approach

Find $f(t)$ and $\hat{f}(t)$, such that

$$
\begin{matrix}
\large \text{Problem} && \xrightarrow{f(t)} && \large \text{Transformed problem} \\
really \Bigg \downarrow hard && && much \Bigg \downarrow easier \\
\large \text{Solution}  && \xleftarrow{\hat{f}(t)} && \large \text{Transformed solution} \\
\end{matrix}
$$


## Fourier series

Complex periodic functions can be written as infinite sums of sine waves

$$
f(t) = a_0 + \sum_{k = 1}^\infty a_k \sin(2 \pi f_0 k t + p_k)
$$


## Fourier series

A finite example

$$
f(t) = \sum_{k = 1}^5 \frac{1}{k} \sin(2 \pi k t + k^2) 
$$

## Fourier series

```{r fourier_ex}
tt <- seq(-1,1,1/100)
TT <- length(tt)
nn <- 5

fs <- matrix(NA, nn, TT)

for(k in 1:nn) {
  fs[k,] <- 1/k * sin(2 * pi * k * tt + k^2)
}
xt <- apply(fs, 2, sum)

par(mai = c(0.9,0.9,0.3,0.1), omi = c(0,0,0,0))

plot.ts(xt, type = "n", las = 1,
        ylab = expression(italic(x[t])))
matlines(t(fs), lty = "solid",
        col = viridis::plasma(nn, 0.7, 0.1, 0.5))
lines(xt, lwd = 2)
```


## Fourier series

```{r}
par(mai = c(0.9,0.9,0.3,0.1), omi = c(0,0,0,0))

plot(seq(nn), apply(fs, 1, max), type = "h", las = 1,
        ylab = "Amplitude", xlab = "Frequency")
```




## Fourier series

[animated example](https://upload.wikimedia.org/wikipedia/commons/7/72/Fourier_transform_time_and_frequency_domains_%28small%29.gif)


## Fourier transform

We can make use of Euler's formula

$$
\cos(2 \pi k) + i \sin(2 \pi k) = e^{i 2 \pi k}
$$

and write the Fourier transform of $f(t)$ as

$$
f(t) = \int_{-\infty}^\infty \hat{f}(k) ~ e^{i 2 \pi t k} ~ d k
$$

where $k$ is the frequency


## Discrete Fourier transform

Fourier transform

$$
f_k = \sum_{n=0}^{N-1} x_t ~ e^{-i 2 \pi n k}
$$


## Fourier transforms in R

__R__ uses what's known as _Fast Fourier transform_ via `fft()`, which returns the amplitude at each frequency

```{r, eval = FALSE, echo = TRUE}
ft <- fft(xt)
## often normalize by the length
ft <- fft(xt) / length(xt)
```


## Fourier represention of our $\{x_t\}$

```{r}
ft <- fft(xt) / TT

par(mai = c(0.9,0.9,0.3,0.1), omi = c(0,0,0,0))

plot(seq(length(tt))-1, Mod(ft), type = "h", lwd = 3,
     las = 1, xlim = c(0,20),
     ylab = "Amplitude", xlab = "Frequency")
```


## Discrete Inverse Fourier transform

Fourier transform

$$
f_k = \sum_{n=0}^{N-1} x_t ~ e^{-i 2 \pi n k}
$$

Inverse

$$
x_t = \sum_{k=0}^{N-1} f_k ~ e^{i 2 \pi n k}
$$


## Inverse Fourier transforms in R

```{r, echo=TRUE, warning=FALSE}
 i <- complex(1, re = 0, im = 1)
xx <- rep(NA, TT)
kk <- seq(TT) - 1
## Inverse Fourier transform
## ft <- fft(xt)
for(t in kk) {
  xx[t+1] <- sum(ft * exp(i*2*pi*kk*t/TT))
}
```


## Original $\{x_t\}$ & our inverse transform

```{r}
par(mai = c(0.9,0.9,0.3,0.1), omi = c(0,0,0,0))
plot.ts(xt, las = 1, lwd = 3, col = "gray",
        ylab = expression(italic(x[t])))
lines(Re(xx), col = "blue", lwd = 1, lty = "dashed")
```


## Inverse Fourier transforms in R

```{r, echo=TRUE}
ift <- fft(ft, inverse = TRUE)
```


## Original $\{x_t\}$ & R's inverse transform

```{r, warning=FALSE}
par(mai = c(0.9,0.9,0.3,0.1), omi = c(0,0,0,0))
plot.ts(xt, las = 1, lwd = 3, col = "gray",
        ylab = expression(italic(x[t])))
lines(Re(ift), col = "darkred", lwd = 1, lty = "dashed")
```


## Spectral analysis

Spectral analysis refers to a _general_ way of decomposing time series into their constituent frequencies


## Spectral analysis

Consider a linear regression model for $\{x_t\}$ with various sines and cosines as predictors

$$
x_t = a_0 + \sum_{k = 1}^{n/2-1} a_k \cos(2 \pi f_0 k t/n) + b_k \sin(2 \pi f_0 k t/n)
$$


## Periodogram

The _periodogram_ measures the contributions of each frequency $k$ to $\{x_t\}$

$$
P_k = a^2_k + b^2_k
$$


## Estimate the periodogram in R

```{r, eval=FALSE, echo=TRUE}
spectrum(xt, log = "on")
spectrum(xt, log = "off")
spectrum(xt, log = "dB")
```


## Periodogram for our $\{x_t\}$

```{r}
par(mai = c(1,0.9,0.3,0.1), omi = c(0,0,0,0))
spectrum(xt, main = "", las = 1, log = "dB")
```

`spectrum(xt, log = "dB")`

## Periodogram for our $\{x_t\}$

```{r}
delta <- 1/100
x_spec <- spectrum(xt, log = "no", plot = FALSE)
sx <- x_spec$freq/delta
sy <- 2*x_spec$spec

par(mai = c(0.9,0.9,0.3,0.1), omi = c(0.2,0,0,0))
plot(sx, sy, type = "l",
     xlab = "Frequency", ylab = "Spectral density")
```

Density on natural scale & frequency in cycles per time


## Spectral density estimation via AR(_p_)

For an AR(_p_) process

$$
x_t = \phi_1 x_{t-1} + \phi_2 x_{t-2} + \cdots + \phi_p x_{t-p} + e_t
$$

The spectral density is

$$
S(f,\phi_1, \dots, \phi_p, \sigma^2) = \frac{\sigma^2 \Delta t}{\vert 1 - \sum_{k = 1}^p \phi_k e^{-i 2 \pi f k \Delta t} \vert ^2}
$$


## Limits to spectral analysis

Spectral analysis works well for

1. stationary time series

2. identifying periodic signals corrupted by noise

What if the frequency changes over time?


## Graphical forms for decomposition

```{r}
par(mfrow = c(1,2), mai = c(0.5,0.5,0.5,0.5), omi = c(1,0,0,0))
## original
plot(c(1,10), c(1,10), type = "n",
     xaxt = "n", yaxt = "n",
     ylab = "", xlab = "")
mtext(side = 1, "Time", line = 0.5)
mtext(side = 2, "Frequency", line = 0.5)
mtext(side = 3, "Original series", line = 0.5,
      adj = 0.5, cex = 1.5)
abline(v = seq(10), col = "blue")
## fourier
plot(c(1,10), c(1,10), type = "n",
     xaxt = "n", yaxt = "n",
     ylab = "", xlab = "")
mtext(side = 1, "Time", line = 0.5)
mtext(side = 2, "Frequency", line = 0.5)
mtext(side = 3, "Fourier transform", line = 0.5,
      adj = 0.5, cex = 1.5)
abline(h = seq(10), col = "darkred")
```




## Wavelets

For non-stationary time series we can use so-called _wavelets_

A wavelet is a function that is localized in time & frequency

